
# Virtual Box

While I do love xen, the innovations with iommu have begun to emerge on other platforms, and it seems likely that further progress will be made on those systems before xen sees them.

Two such improvements are EFI BIOS and PCI passthrough, both of which are now supported in VirtualBox, and to a lesser extent even Parallels.  However, parallels only supports EFI and for Windows or OS X, it doesn't supply efivars to linux.

Parallels has also been lacking in linux support in general as of late, which led me to try out VirtualBox.  What I am finding is that VirtualBox is significantly more up to date, and focuses on the power user audience, so I have begun the transition and will probably be using their tools going forward.

My most recent advent was getting Arch installed so I could try it out as a possible debian alternative for desktop use.


## OS X

VirtualBox now supports OS X guests.

This gives it a very distinct advantage over almost ALL of its competition, especially being a cross platform FREE service.

Xen has an EFI bootloader, though documentation of OS X installation is scarce, and the same holds true of KVM.

Parallels has support, if you're running a licensed server copy of OS X, which is utter bullshit.  OS X, like every other OS, should be virtualization compatible without "stupid" limitations.


## VGA Passthrough

VirtualBox now has limited support for IOMMU, and graphics passthrough:

- [Ubuntu Laptop GPU Passthrough](http://askubuntu.com/questions/202926/how-to-use-nvidia-geforce-m310-on-ubuntu-12-10-running-as-guest-in-virtualbox)

If this works even with an additional 10% loss in performance, it would still be a better place than where I am with Xen.


## Fuck it Mentality

If shit hits the fan and I still can't get VGA Passthrough working in linux with Xen I can always try VirtualBox.

Even better, I could use Arch as my primary desktop OS and run IPFire, my Web & Comm server's in VirtualBox and not even worry about VGA Passthrough.

Granted I'd still have ot get my graphics drivers working on Arch, and I would also be (basically) abandoning over a years worth of effort, but probably not forever.


## VBox Stupid Networking

One big pet-peev I have is that VirtualBox has a really dumb set of network options.  They have nearly twice as many options, with half as much functionality.  Their custom NAT breaks local access and ping's (for no valid reason), and their host-only adapter does not bridge to the actual network.

Parallels at least provides pre-configured options, the downside is I cannot (easily) set the NAT DHCP addresses, but the upside is I don't need two adapters to maintain both internet access and static local connectivity.

In any event, the configuration I am now using involves their default NAT, and then a `hostonlyif` which has its own network address, but DHCP turned off.  I can then assign the static IP from the guest that I can use in my hosts files for mapping and for ssh.


## EFI Booting

VirtualBox does have EFI support, but it's currently in testing.

Apparently their EFI menu uses "Volatile" NVRam (yes, that is "volatile non-volatile ram").  This means that the first installation will add your boot option, and it will work with reboots up until you shutdown.  When you shutdown it wipes its memory.

Fortunately there are two ways to work around this, both are equally decent, and you can add both as a fallback for emergencies.

First, the EFI shell says it will run `startup.nsh`, which is an `nsh` shell file for EFI.  This file is inside the EFI partition, **not** the boot partition.  So, if you have a `/boot/efi` mounted fat32, then what you want to do is add `/boot/efi/start.nsh` with:

    fs0:\EFI\grub\grubx64.efi

Where the above is the parth from the fat32 partition to the efi file generated by grub.

Now, this option does work, but... it adds a 5 second overhead to boot times because it will wait for commands before running any startup.nsh files it locates.

Which brings us to the second, slightly superior option.  This method can be done in addition to the above method, and will process first, so as a "just-in-case" situation it is not bad.

From the mounted directory, we want to create `/boot/efi/EFI/boot/` and copy the `grubx64.efi` to `bootx64.efi` inside the boot folder.  From the fat32 drive the path would be `/EFI/boot/bootx64.efi`.  The system will apparently pickup on that name first, and it will execute it without waiting or looking at the startup.nsh script.

